并查集可以用于解决图的连通性问题，解决图中有几个连通分支。并查集由一个整数型的数组和两个函数构成。数组pre[]记录了每个点的父节点是什么，对于孤立的节点，父节点指向自己。函数find是查找，同时还执行路径压缩的功能以提高后续的查询效率，即将待查节点至根节点的整个路径上的所有节点的父节点都修改为该连通分支的根节点），join是合并两个连通分支，合并方式是先找出两个节点的根节点，再把其中一个根节点的父节点指向另一个根节点，合并会增加路径的长度。

位图算法用于对大量整形数据做去重和查询。虽然hashset和hashmap也可以实现去重和查询，但是存储开销要比位图算法大很多，而且在做与查询时位图算法可以充分利用按位与运算的高效性来实现极高的查询性能。但是位图算法的缺点是不支持非运算。Google开发的EWAHCompressedBitmap就是对位图算法的高效实现。

简单的递归程序都是自顶向下进行分解的过程，其中会包含大量的重复计算，动态规划自底向上计算，可以大幅降低计算代价。

最优子结构原理：当要求一个问题的最优解时，构成整体解的子问题的解也必须是最优的，以矩阵连乘问题为例，无论最后一次乘法的位置在哪，其两侧的子序列的乘积一定是最优的。最优子结构往往会含有大量重复的子问题。

最优二分搜索树问题：己知m个单词的查找概率p1,p2,...,pm和对应n+1个外部节点的不成功概率q0,q1,...,qn，有$\sum_{0}^{n+1}q_i+\sum_{i=0}^{m}p_i=1$，构造一种二分搜索树使得平均搜索代价最小。

文本串T与模式串P的K近似匹配问题:对于非负整数K,样本P在文本T中的K近似匹配是指P在T中包含至多K个差别的匹配，这里的差别包含三种情况:
*修改:P与T对应位置的字符不同
*删除:T中包含一个未出现在P中的字符
*插入:T中不含有P中的一个字符
K近似匹配是一种简单的模式匹配算法，在语音识别、字符识别OCR中有广泛的应用，该问题可以用动态规范来解决。

用动态规划解题经常碰到的情况是，K个整型变量构成一个状态，如果K个整型变量的取值范围分别为N1,N2,...,NK，则可以用一个K维数组A[N1][N2]...[Nk]来存储所有可能的状态。

解动态规划问题的特点：
* 最优子结构性质
* 无后效性:当前的若干个状态值一旦确定，则此后过程的演变就只和这若干个状态的值有关，和之前采用哪种手段或者经过哪条路径演变到当前状态没有关系。


